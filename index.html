<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StickMotion</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        zinc: {
                            750: '#2d2d30',
                            850: '#1f1f22',
                            950: '#0c0c0e',
                        }
                    },
                    fontFamily: {
                        sans: ['-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'Roboto', 'Helvetica', 'Arial', 'sans-serif'],
                    }
                }
            }
        }
    </script>
    <style>
        body {
            background-color: #09090b; /* Zinc-950 */
            color: #e4e4e7; /* Zinc-200 */
            overflow: hidden;
        }
        
        /* Modern Scrollbar */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #3f3f46; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #52525b; }

        canvas {
            background-color: #ffffff;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            cursor: crosshair;
        }

        /* Timeline Thumbnails */
        .frame-thumb { transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1); }
        .frame-thumb.active { ring-width: 2px; --tw-ring-color: #3b82f6; transform: translateY(-2px); }
        .frame-thumb .delete-btn { display: none; }
        .frame-thumb:hover .delete-btn { display: flex; }
        .frame-thumb.dragging { opacity: 0.5; transform: scale(0.95); }

        .no-select { user-select: none; -webkit-user-select: none; }

        .loader {
            border: 3px solid rgba(255,255,255,0.1);
            border-top: 3px solid #3b82f6;
            border-radius: 50%;
            width: 24px; height: 24px;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Input Range Styling */
        input[type=range] { -webkit-appearance: none; background: transparent; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 12px; width: 12px;
            border-radius: 50%; background: #e4e4e7; margin-top: -4px; 
            box-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer;
            background: #3f3f46; border-radius: 2px;
        }
    </style>
</head>
<body class="h-screen w-screen flex flex-col font-sans antialiased selection:bg-blue-500 selection:text-white">

    <!-- Top Toolbar: Global Project & Playback -->
    <div class="h-14 bg-zinc-900 border-b border-zinc-800 flex items-center px-4 justify-between no-select shrink-0 z-20 shadow-sm">
        <div class="flex items-center space-x-6">
            <div class="flex items-center space-x-2">
                <!-- Rebranded Logo Text -->
                <span class="text-sm font-semibold text-zinc-400 tracking-tight">Stick<span class="text-blue-500">Motion</span></span>
            </div>
            
            <div class="h-6 w-px bg-zinc-700 mx-2"></div>

            <!-- Playback Controls -->
            <div class="flex items-center bg-zinc-800 rounded-lg p-1 border border-zinc-700">
                <button onclick="app.play()" id="btn-play" class="flex items-center px-3 py-1 bg-zinc-700 hover:bg-zinc-600 text-green-400 rounded-md text-xs font-medium transition">
                    <svg class="w-3 h-3 mr-1.5" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg> Play
                </button>
                <button onclick="app.stop()" id="btn-stop" class="hidden flex items-center px-3 py-1 bg-red-900/30 hover:bg-red-900/50 text-red-400 rounded-md text-xs font-medium transition">
                    <svg class="w-3 h-3 mr-1.5" fill="currentColor" viewBox="0 0 24 24"><path d="M6 6h12v12H6z"/></svg> Stop
                </button>
                
                <div class="mx-3 flex items-center space-x-2">
                    <span class="text-[10px] text-zinc-500 font-bold uppercase tracking-wider">Speed</span>
                    <input type="range" min="1" max="30" value="12" class="w-20" oninput="app.updateFps(this.value)">
                    <span id="fps-display" class="text-[10px] font-mono text-zinc-400 w-4">12</span>
                </div>
                
                <div class="flex items-center space-x-2 px-2 border-l border-zinc-700">
                    <button type="button" onclick="app.toggleLoop()" id="btn-loop" class="text-xs px-2 py-0.5 rounded bg-blue-500/10 text-blue-400 border border-blue-500/20">Loop</button>
                    <button type="button" onclick="app.toggleSmooth()" id="btn-smooth" class="text-xs px-2 py-0.5 rounded bg-blue-500/10 text-blue-400 border border-blue-500/20">Smooth</button>
                </div>
            </div>
        </div>

        <div class="flex items-center space-x-3">
            <div class="flex items-center space-x-1 text-xs">
                <button onclick="app.confirmNewProject()" class="px-3 py-1.5 hover:bg-zinc-800 text-zinc-300 rounded transition">New</button>
                <button onclick="app.saveProject()" class="px-3 py-1.5 hover:bg-zinc-800 text-zinc-300 rounded transition">Save</button>
                <button onclick="document.getElementById('load-input').click()" class="px-3 py-1.5 hover:bg-zinc-800 text-zinc-300 rounded transition">Load</button>
                <button onclick="app.exportGif()" class="ml-1 px-3 py-1.5 bg-blue-600 hover:bg-blue-500 text-white font-medium rounded shadow-lg shadow-blue-900/20 transition flex items-center">
                    <span>Export GIF</span>
                </button>
            </div>
            <input type="file" id="load-input" class="hidden" accept=".json" onchange="app.loadProject(this)">
        </div>
    </div>

    <!-- Main Workspace -->
    <div class="flex-1 bg-zinc-950 flex relative overflow-hidden">
        
        <!-- Left Sidebar: Tools & Inspector -->
        <div class="w-72 bg-zinc-900/50 border-r border-zinc-800 flex flex-col shrink-0 z-10 backdrop-blur-sm">
            
            <!-- Figures Section -->
            <div class="p-4 border-b border-zinc-800">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-xs font-bold text-zinc-500 uppercase tracking-wider">Figures</h3>
                    <div class="flex space-x-1">
                        <button onclick="app.openBuilder()" class="text-xs bg-zinc-800 hover:bg-zinc-700 text-zinc-200 px-2 py-1 rounded border border-zinc-700 transition flex items-center" title="Open Figure Designer">
                            <svg class="w-3 h-3 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg>
                            Create
                        </button>
                        <button onclick="app.addFigure()" class="text-xs bg-blue-900/30 hover:bg-blue-900/50 text-blue-200 px-2 py-1 rounded border border-blue-800/50 transition flex items-center">
                            <span class="mr-1 text-lg leading-none align-middle">+</span> Stick Figure
                        </button>
                    </div>
                </div>

                <div class="space-y-3">
                    <!-- Figure Properties Grid -->
                    <div class="grid grid-cols-2 gap-2">
                         <button onclick="app.flipFigure()" class="flex items-center justify-center px-2 py-2 bg-zinc-800 hover:bg-zinc-700 text-zinc-400 hover:text-white rounded text-xs transition border border-zinc-800 hover:border-zinc-600">Flip X</button>
                        <button onclick="app.centerFigure()" class="flex items-center justify-center px-2 py-2 bg-zinc-800 hover:bg-zinc-700 text-zinc-400 hover:text-white rounded text-xs transition border border-zinc-800 hover:border-zinc-600">Center</button>
                        <button onclick="app.scaleFigure(1.1)" class="flex items-center justify-center px-2 py-2 bg-zinc-800 hover:bg-zinc-700 text-zinc-400 hover:text-white rounded text-xs transition border border-zinc-800 hover:border-zinc-600">Scale +</button>
                        <button onclick="app.scaleFigure(0.9)" class="flex items-center justify-center px-2 py-2 bg-zinc-800 hover:bg-zinc-700 text-zinc-400 hover:text-white rounded text-xs transition border border-zinc-800 hover:border-zinc-600">Scale -</button>
                    </div>

                    <!-- Color & Delete -->
                    <div class="flex items-center space-x-2">
                        <div class="relative flex-1 group">
                            <input type="color" id="color-picker" class="absolute opacity-0 w-full h-full cursor-pointer" onchange="app.setFigureColor(this.value)">
                            <div class="w-full h-8 bg-zinc-800 rounded border border-zinc-700 flex items-center justify-center text-xs text-zinc-400 group-hover:bg-zinc-700 group-hover:border-zinc-600 transition">
                                <div id="color-preview" class="w-4 h-4 rounded-full bg-black mr-2 border border-white/10"></div>
                                Change Color
                            </div>
                        </div>
                        <button onclick="app.deleteSelectedFigure()" class="w-8 h-8 flex items-center justify-center bg-red-500/10 hover:bg-red-500/20 text-red-500 rounded border border-red-500/20 transition" title="Delete Figure">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Frame Controls -->
            <div class="p-4 border-b border-zinc-800">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-xs font-bold text-zinc-500 uppercase tracking-wider">Timeline</h3>
                    <div class="flex items-center">
                        <input type="checkbox" id="onion-check" checked class="accent-blue-500 mr-1.5" onchange="app.render()">
                        <label for="onion-check" class="text-xs text-zinc-400 cursor-pointer select-none">Onion Skin</label>
                    </div>
                </div>
                <div class="mb-3 bg-zinc-900 p-2 rounded border border-zinc-800">
                    <div class="flex justify-between text-[10px] text-zinc-400 mb-2">
                        <span class="font-semibold text-zinc-300">Frame Duration</span>
                        <span id="duration-display" class="font-mono text-blue-400">1.0x</span>
                    </div>
                    <!-- FIX: Added draggable="false" and stopPropagation to prevent drag-lock -->
                    <input type="range" min="0.1" max="10.0" step="0.1" value="1.0" id="frame-duration" class="w-full accent-blue-500" draggable="false" onmousedown="event.stopPropagation()" oninput="app.setFrameDuration(this.value)">
                    <div class="flex justify-between text-[8px] text-zinc-600 mt-1 px-0.5">
                        <span>Fast</span>
                        <span>Slow</span>
                    </div>
                </div>
                <button onclick="app.addFrame()" class="w-full bg-blue-600 hover:bg-blue-500 text-white py-2.5 rounded font-semibold shadow-lg shadow-blue-900/20 active:scale-[0.98] transition flex items-center justify-center mb-2">
                    <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg>
                    Add Frame <span class="ml-1 opacity-60 font-normal text-[10px] tracking-wide">(SPACE)</span>
                </button>
            </div>

            <!-- Scene Settings -->
            <div class="p-4">
                <h3 class="text-xs font-bold text-zinc-500 uppercase tracking-wider mb-3">Scene</h3>
                <div class="grid grid-cols-2 gap-3 mb-3">
                    <div>
                        <label class="text-[10px] text-zinc-500 font-bold block mb-1">WIDTH</label>
                        <input type="number" id="canvas-w" value="800" class="w-full bg-zinc-950 text-zinc-300 text-xs p-2 rounded border border-zinc-800 focus:border-blue-500 focus:outline-none transition font-mono" onchange="app.setCanvasSize()">
                    </div>
                    <div>
                        <label class="text-[10px] text-zinc-500 font-bold block mb-1">HEIGHT</label>
                        <input type="number" id="canvas-h" value="500" class="w-full bg-zinc-950 text-zinc-300 text-xs p-2 rounded border border-zinc-800 focus:border-blue-500 focus:outline-none transition font-mono" onchange="app.setCanvasSize()">
                    </div>
                </div>
                <div class="flex flex-col space-y-2">
                    <button onclick="document.getElementById('bg-input').click()" class="text-xs bg-zinc-800 hover:bg-zinc-700 text-zinc-300 py-2 rounded border border-zinc-700 transition">Set Background Image...</button>
                    <input type="file" id="bg-input" class="hidden" accept="image/*" onchange="app.loadBackground(this)">
                    <button onclick="app.confirmClearStage()" class="text-xs text-zinc-500 hover:text-red-400 py-1 transition flex items-center justify-center">
                        <svg class="w-3 h-3 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                        Clear Stage
                    </button>
                </div>
            </div>
            <div class="flex-1"></div>
            <div class="p-4 text-center border-t border-zinc-800">
                <p class="text-[10px] text-zinc-600">Drag <span class="text-orange-500">Orange</span> to move.<br>Drag <span class="text-red-500">Red</span> to rotate.</p>
            </div>
        </div>

        <!-- Canvas Area -->
        <div class="flex-1 flex flex-col min-w-0 bg-[#121214]">
            <div class="flex-1 overflow-auto flex items-center justify-center p-8 relative" id="canvas-wrapper">
                <canvas id="main-canvas" width="800" height="500" class="rounded-sm bg-white"></canvas>
            </div>
            <!-- Timeline Bottom Bar -->
            <div class="h-36 bg-zinc-900 border-t border-zinc-800 flex flex-col shrink-0 z-20">
                <div class="h-8 bg-zinc-900 border-b border-zinc-800 flex items-center px-4 justify-between">
                    <div class="flex items-center space-x-4">
                        <span class="text-[10px] font-bold text-zinc-500 uppercase tracking-wider">Animation Timeline</span>
                    </div>
                    <span class="text-xs font-mono text-zinc-500" id="frame-counter">0 / 0</span>
                </div>
                <div class="flex-1 overflow-x-auto timeline-scroll flex items-center p-3 space-x-3" id="timeline-track"></div>
            </div>
        </div>
    </div>

    <!-- Figure Designer Modal -->
    <div id="builder-modal" class="fixed inset-0 bg-black/90 backdrop-blur-sm flex items-center justify-center z-50 hidden">
        <div class="bg-zinc-900 border border-zinc-700 w-[800px] h-[550px] rounded-xl shadow-2xl flex overflow-hidden">
            <!-- Canvas Side -->
            <div class="flex-1 bg-[#e5e5e5] relative flex items-center justify-center overflow-hidden cursor-crosshair" id="builder-canvas-container">
                <canvas id="builder-canvas" width="600" height="550"></canvas>
                <div class="absolute top-4 left-4 text-zinc-500 text-xs font-bold opacity-50 pointer-events-none">DESIGNER MODE</div>
            </div>
            
            <!-- Controls Side -->
            <div class="w-64 bg-zinc-800 border-l border-zinc-700 flex flex-col">
                <div class="p-4 border-b border-zinc-700">
                    <h3 class="text-sm font-bold text-white mb-1">Figure Designer</h3>
                    <p class="text-[10px] text-zinc-400">Design your custom figure skeleton.</p>
                </div>
                
                <div class="p-4 space-y-4 overflow-y-auto flex-1">
                    <!-- Add Tools -->
                    <div>
                        <label class="text-[10px] font-bold text-zinc-500 uppercase tracking-wider mb-2 block">Add Segment</label>
                        <div class="grid grid-cols-2 gap-2">
                            <button onclick="builder.addSegment('line')" class="flex flex-col items-center justify-center p-2 bg-zinc-700 hover:bg-zinc-600 rounded border border-zinc-600 transition">
                                <div class="w-6 h-0.5 bg-zinc-300 mb-1"></div>
                                <span class="text-[10px] text-zinc-300">Add Line</span>
                            </button>
                            <button onclick="builder.addSegment('circle')" class="flex flex-col items-center justify-center p-2 bg-zinc-700 hover:bg-zinc-600 rounded border border-zinc-600 transition">
                                <div class="w-3 h-3 rounded-full border-2 border-zinc-300 mb-1"></div>
                                <span class="text-[10px] text-zinc-300">Add Circle</span>
                            </button>
                        </div>
                    </div>

                    <!-- Selected Properties -->
                    <div id="builder-props" class="opacity-50 pointer-events-none transition-opacity">
                        <label class="text-[10px] font-bold text-zinc-500 uppercase tracking-wider mb-2 block">Properties</label>
                        <div class="space-y-3">
                            <div>
                                <label class="text-[10px] text-zinc-400 flex justify-between">Thickness <span id="b-thick-val" class="text-white font-mono">14</span></label>
                                <input type="range" min="2" max="40" value="14" id="b-thickness" class="w-full" oninput="builder.updateProp('thickness', this.value)">
                            </div>
                            <div>
                                <label class="text-[10px] text-zinc-400 flex justify-between">Length/Radius <span id="b-len-val" class="text-white font-mono">40</span></label>
                                <input type="range" min="0" max="200" value="40" id="b-length" class="w-full" oninput="builder.updateProp('length', this.value)">
                            </div>
                            <div class="flex items-center justify-between pt-1">
                                <span class="text-[10px] text-zinc-400">Type</span>
                                <button onclick="builder.toggleType()" class="text-[10px] bg-zinc-900 px-2 py-1 rounded border border-zinc-600 hover:border-zinc-400 text-zinc-300">Toggle Line/Circle</button>
                            </div>
                        </div>
                        <button onclick="builder.deleteSegment()" class="w-full mt-4 bg-red-900/30 hover:bg-red-900/50 text-red-300 py-2 rounded text-xs border border-red-900/50 transition">Delete Segment</button>
                    </div>
                </div>

                <!-- Footer Actions -->
                <div class="p-4 border-t border-zinc-700 bg-zinc-850">
                    <button onclick="builder.saveAndAdd()" class="w-full bg-blue-600 hover:bg-blue-500 text-white py-2 rounded font-bold text-sm shadow-lg shadow-blue-900/20 transition mb-2">Add to Animation</button>
                    <button onclick="builder.close()" class="w-full bg-transparent hover:bg-zinc-700 text-zinc-400 hover:text-zinc-200 py-2 rounded text-xs transition">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Loading Modal -->
    <div id="loading-modal" class="fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-50 hidden">
        <div class="bg-zinc-900 border border-zinc-700 p-8 rounded-xl shadow-2xl flex flex-col items-center">
            <div class="loader mb-4 border-blue-500 border-t-blue-500"></div>
            <h3 class="text-lg font-bold text-white">Generating GIF</h3>
            <p class="text-zinc-400 text-sm mt-2">Rendering frames...</p>
        </div>
    </div>

    <!-- Confirm Modal -->
    <div id="confirm-modal" class="fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-50 hidden">
        <div class="bg-zinc-900 border border-zinc-700 p-6 rounded-xl shadow-2xl max-w-sm w-full mx-4">
            <h3 id="confirm-title" class="text-lg font-bold text-white mb-2">Confirmation</h3>
            <p id="confirm-msg" class="text-zinc-400 mb-6 text-sm">Are you sure?</p>
            <div class="flex justify-end space-x-3">
                <button onclick="app.closeModal()" class="px-4 py-2 bg-zinc-800 hover:bg-zinc-700 text-white rounded text-sm transition">Cancel</button>
                <button id="confirm-btn" onclick="app.executeConfirm()" class="px-4 py-2 bg-red-600 hover:bg-red-500 text-white rounded text-sm font-bold transition shadow-lg shadow-red-900/20">Confirm</button>
            </div>
        </div>
    </div>

    <script>
        const SEGMENT_LINE = 'line';
        const SEGMENT_CIRCLE = 'circle';

        class Joint {
            constructor(id, parentId, length, angle, type = SEGMENT_LINE, radius = 0, thickness = 14) {
                this.id = id;
                this.parentId = parentId;
                this.length = length;
                this.angle = angle;
                this.type = type;
                this.radius = radius;
                this.thickness = thickness;
                this.x = 0;
                this.y = 0;
            }
            clone() { return new Joint(this.id, this.parentId, this.length, this.angle, this.type, this.radius, this.thickness); }
        }

        class Figure {
            constructor() {
                this.id = Math.random().toString(36).substr(2, 9);
                this.x = 400;
                this.y = 300;
                this.joints = [];
                this.scale = 1.0;
                this.color = '#000000';
                this.selected = false;
            }
            clone() {
                const f = new Figure();
                f.id = this.id;
                f.x = this.x; f.y = this.y;
                f.scale = this.scale; f.color = this.color;
                f.joints = this.joints.map(j => j.clone());
                return f;
            }
            updatePositions() {
                const jointMap = {};
                this.joints.forEach(j => jointMap[j.id] = j);
                const calcJoint = (joint) => {
                    if (joint.parentId === null) {
                        joint.x = this.x; joint.y = this.y;
                    } else {
                        const parent = jointMap[joint.parentId];
                        if (parent) {
                            joint.x = parent.x + Math.cos(joint.angle) * (joint.length * this.scale);
                            joint.y = parent.y + Math.sin(joint.angle) * (joint.length * this.scale);
                        }
                    }
                };
                const roots = this.joints.filter(j => j.parentId === null);
                const process = (j) => {
                    calcJoint(j);
                    this.joints.filter(child => child.parentId === j.id).forEach(process);
                };
                roots.forEach(process);
            }
        }

        // --- FIGURE BUILDER MODULE ---
        const builder = {
            canvas: null,
            ctx: null,
            figure: null,
            selectedId: null,
            dragTarget: null,
            isOpen: false,

            init() {
                this.canvas = document.getElementById('builder-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
                window.addEventListener('mousemove', (e) => this.onMouseMove(e));
                window.addEventListener('mouseup', (e) => this.onMouseUp(e));
            },

            open() {
                this.isOpen = true;
                document.getElementById('builder-modal').classList.remove('hidden');
                this.figure = new Figure();
                this.figure.x = this.canvas.width / 2;
                this.figure.y = this.canvas.height / 2;
                this.figure.joints = [new Joint('root', null, 0, 0)];
                this.selectedId = 'root';
                this.updateUI();
                this.render();
            },

            close() {
                this.isOpen = false;
                document.getElementById('builder-modal').classList.add('hidden');
            },

            addSegment(type) {
                if (!this.selectedId) return;
                const id = Math.random().toString(36).substr(2, 9);
                const angle = Math.PI / 2;
                const length = 40;
                const j = new Joint(id, this.selectedId, length, angle, type, 20, 14);
                this.figure.joints.push(j);
                this.selectedId = id;
                this.updateUI();
                this.render();
            },

            deleteSegment() {
                if (!this.selectedId || this.selectedId === 'root') return;
                const toRemove = [this.selectedId];
                const getAllChildren = (pid) => {
                    this.figure.joints.filter(j => j.parentId === pid).forEach(c => {
                        toRemove.push(c.id);
                        getAllChildren(c.id);
                    });
                };
                getAllChildren(this.selectedId);
                this.figure.joints = this.figure.joints.filter(j => !toRemove.includes(j.id));
                this.selectedId = this.figure.joints[0].id;
                this.updateUI();
                this.render();
            },

            updateProp(prop, val) {
                if (!this.selectedId || this.selectedId === 'root') return;
                const j = this.figure.joints.find(j => j.id === this.selectedId);
                if (j) {
                    if (prop === 'thickness') {
                        j.thickness = parseInt(val);
                        document.getElementById('b-thick-val').innerText = j.thickness;
                    } else if (prop === 'length') {
                        j.length = parseInt(val);
                        if(j.type === SEGMENT_CIRCLE) j.radius = j.length / 2;
                        document.getElementById('b-len-val').innerText = j.length;
                    }
                    this.render();
                }
            },

            toggleType() {
                if (!this.selectedId || this.selectedId === 'root') return;
                const j = this.figure.joints.find(j => j.id === this.selectedId);
                if(j) {
                    j.type = j.type === SEGMENT_LINE ? SEGMENT_CIRCLE : SEGMENT_LINE;
                    if(j.type === SEGMENT_CIRCLE && j.radius === 0) j.radius = 20;
                    this.render();
                }
            },

            saveAndAdd() {
                const newFig = new Figure();
                newFig.joints = this.figure.joints.map(j => j.clone());
                newFig.x = 400;
                newFig.y = 300;
                app.addCustomFigure(newFig);
                this.close();
            },

            getMousePos(e) {
                const rect = this.canvas.getBoundingClientRect();
                return { x: e.clientX - rect.left, y: e.clientY - rect.top };
            },

            onMouseDown(e) {
                if (!this.isOpen) return;
                const pos = this.getMousePos(e);
                this.figure.updatePositions();
                for (let i = this.figure.joints.length - 1; i >= 0; i--) {
                    const j = this.figure.joints[i];
                    if (Math.hypot(pos.x - j.x, pos.y - j.y) < 8) {
                        this.selectedId = j.id;
                        this.dragTarget = j;
                        this.updateUI();
                        this.render();
                        return;
                    }
                }
            },

            onMouseMove(e) {
                if (!this.isOpen || !this.dragTarget) return;
                if (this.dragTarget.id === 'root') return;
                
                const pos = this.getMousePos(e);
                const parent = this.figure.joints.find(j => j.id === this.dragTarget.parentId);
                if (parent) {
                    const dx = pos.x - parent.x;
                    const dy = pos.y - parent.y;
                    this.dragTarget.angle = Math.atan2(dy, dx);
                    this.dragTarget.length = Math.hypot(dx, dy);
                    if(this.selectedId === this.dragTarget.id) {
                        document.getElementById('b-length').value = Math.round(this.dragTarget.length);
                        document.getElementById('b-len-val').innerText = Math.round(this.dragTarget.length);
                    }
                    this.render();
                }
            },

            onMouseUp(e) { this.dragTarget = null; },

            updateUI() {
                const props = document.getElementById('builder-props');
                const isRoot = this.selectedId === 'root';
                
                if (isRoot || !this.selectedId) {
                    props.classList.add('opacity-50', 'pointer-events-none');
                } else {
                    props.classList.remove('opacity-50', 'pointer-events-none');
                    const j = this.figure.joints.find(j => j.id === this.selectedId);
                    if (j) {
                        document.getElementById('b-thickness').value = j.thickness;
                        document.getElementById('b-thick-val').innerText = j.thickness;
                        document.getElementById('b-length').value = Math.round(j.length);
                        document.getElementById('b-len-val').innerText = Math.round(j.length);
                    }
                }
            },

            render() {
                this.ctx.fillStyle = "#e5e5e5";
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.strokeStyle = "#d4d4d4";
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                for(let x=0; x<this.canvas.width; x+=20) { this.ctx.moveTo(x,0); this.ctx.lineTo(x, this.canvas.height); }
                for(let y=0; y<this.canvas.height; y+=20) { this.ctx.moveTo(0,y); this.ctx.lineTo(this.canvas.width, y); }
                this.ctx.stroke();

                this.figure.updatePositions();
                this.figure.joints.forEach(j => {
                    if(!j.parentId) return;
                    const p = this.figure.joints.find(x => x.id === j.parentId);
                    if(!p) return;
                    this.ctx.strokeStyle = "#000";
                    this.ctx.fillStyle = "#000";
                    this.ctx.lineWidth = j.thickness;
                    this.ctx.lineCap = 'round';
                    
                    if(j.type === SEGMENT_CIRCLE) {
                        const dx = j.x - p.x; const dy = j.y - p.y;
                        const angle = Math.atan2(dy, dx);
                        const r = j.length / 2;
                        const cx = j.x - Math.cos(angle) * (r*0.5); 
                        const cy = j.y - Math.sin(angle) * (r*0.5);
                        const chinX = cx - Math.cos(angle) * r;
                        const chinY = cy - Math.sin(angle) * r;
                        this.ctx.beginPath(); this.ctx.moveTo(p.x, p.y); this.ctx.lineTo(chinX, chinY); this.ctx.stroke();
                        this.ctx.beginPath(); this.ctx.arc(cx, cy, r, 0, Math.PI*2); this.ctx.fill();
                    } else {
                        this.ctx.beginPath(); this.ctx.moveTo(p.x, p.y); this.ctx.lineTo(j.x, j.y); this.ctx.stroke();
                    }
                });

                this.figure.joints.forEach(j => {
                    this.ctx.beginPath();
                    this.ctx.arc(j.x, j.y, 5, 0, Math.PI*2);
                    if (j.id === this.selectedId) {
                        this.ctx.fillStyle = "#3b82f6";
                        this.ctx.strokeStyle = "#fff";
                        this.ctx.lineWidth = 2;
                        this.ctx.stroke();
                    } else if (j.id === 'root') {
                        this.ctx.fillStyle = "#f97316";
                    } else {
                        this.ctx.fillStyle = "#ef4444";
                    }
                    this.ctx.fill();
                });
            }
        };

        const app = {
            canvas: document.getElementById('main-canvas'),
            ctx: document.getElementById('main-canvas').getContext('2d'),
            frames: [],
            frameDelays: [],
            currentFrameIndex: 0,
            figures: [],
            bgImage: null,
            fps: 12,
            isPlaying: false,
            lastTime: 0,
            playbackAccumulator: 0,
            isLooping: true,
            isSmooth: true,
            showOnion: true,
            dragTarget: null,
            mouseX: 0, mouseY: 0,
            draggedFrameIndex: null,
            handleRadius: 4,
            pendingAction: null,

            init() {
                this.addFigure();
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
                this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
                window.addEventListener('mousemove', (e) => this.onMouseMove(e));
                window.addEventListener('mouseup', (e) => this.onMouseUp(e));
                window.addEventListener('keydown', (e) => {
                    if (e.code === 'Space') {
                        e.preventDefault();
                        if(this.isPlaying) this.stop(); else this.addFrame();
                    }
                });
                this.toggleLoop(true);
                this.toggleSmooth(true);
                builder.init();
                this.updateTimeline();
                this.render();
            },

            resizeCanvas() { },

            openBuilder() { builder.open(); },
            addCustomFigure(fig) {
                this.figures.push(fig);
                this.selectFigure(fig);
                this.render();
            },

            createStickman() {
                const f = new Figure();
                const j = [];
                const hip='hip', abs='abs', chest='chest', neck='neck';
                const lShldr='lShldr', lElbow='lElbow', lHand='lHand';
                const rShldr='rShldr', rElbow='rElbow', rHand='rHand';
                const lKnee='lKnee', lFoot='lFoot', rKnee='rKnee', rFoot='rFoot';

                j.push(new Joint(hip, null, 0, 0));
                j.push(new Joint(abs, hip, 23, -Math.PI/2));
                j.push(new Joint(chest, abs, 23, -Math.PI/2));
                j.push(new Joint(neck, chest, 40, -Math.PI/2, SEGMENT_CIRCLE, 20));
                
                j.push(new Joint(lShldr, chest, 25, Math.PI - 0.2));
                j.push(new Joint(lElbow, lShldr, 25, Math.PI - 0.5));
                j.push(new Joint(lHand, lElbow, 20, Math.PI - 0.2));

                j.push(new Joint(rShldr, chest, 25, 0.2));
                j.push(new Joint(rElbow, rShldr, 25, 0.5));
                j.push(new Joint(rHand, rElbow, 20, 0.2));

                j.push(new Joint(lKnee, hip, 35, Math.PI/2 + 0.3));
                j.push(new Joint(lFoot, lKnee, 35, Math.PI/2 + 0.1));

                j.push(new Joint(rKnee, hip, 35, Math.PI/2 - 0.3));
                j.push(new Joint(rFoot, rKnee, 35, Math.PI/2 - 0.1));

                f.joints = j;
                return f;
            },

            addFigure() {
                const fig = this.createStickman();
                if (this.figures.length > 0) { fig.x += 20; fig.y += 20; }
                this.figures.push(fig);
                this.selectFigure(fig);
                this.render();
            },

            deleteSelectedFigure() {
                const index = this.figures.findIndex(f => f.selected);
                if (index !== -1) {
                    this.figures.splice(index, 1);
                    this.render();
                }
            },

            setFrameDuration(val) {
                const delay = parseFloat(val);
                document.getElementById('duration-display').innerText = delay.toFixed(1) + 'x';
                
                if (this.frameDelays[this.currentFrameIndex] !== undefined) {
                    this.frameDelays[this.currentFrameIndex] = delay;
                    
                    // OPTIMIZATION: Don't rebuild the whole timeline. Just update the current frame's thumb.
                    const container = document.getElementById('timeline-track');
                    if (container && container.children[this.currentFrameIndex]) {
                        const wrapper = container.children[this.currentFrameIndex];
                        
                        const badge = wrapper.querySelector('.absolute.top-0.left-0');
                        if (badge) {
                            badge.innerText = delay.toFixed(1) + 'x';
                            badge.className = `absolute top-0 left-0 text-[9px] px-1.5 py-0.5 font-mono z-10 rounded-br font-bold ${delay > 1.0 ? 'bg-blue-600 text-white' : 'bg-zinc-700 text-zinc-400'}`;
                        }
                        
                        const barFill = wrapper.querySelector('.absolute.bottom-0 div');
                        if (barFill) {
                            let widthPct = (delay / 10.0) * 100;
                            widthPct = Math.max(5, widthPct); 
                            barFill.style.width = widthPct + '%';
                            barFill.className = `h-full ${delay > 1.0 ? 'bg-blue-500' : 'bg-zinc-600'}`;
                        }
                    }
                }
            },

            toggleLoop(forceState) {
                if (forceState !== undefined) this.isLooping = forceState;
                else this.isLooping = !this.isLooping;
                const btn = document.getElementById('btn-loop');
                if (this.isLooping) {
                    btn.classList.add('bg-blue-500/10', 'text-blue-400', 'border-blue-500/20');
                    btn.classList.remove('bg-zinc-700', 'text-zinc-400', 'border-transparent');
                } else {
                    btn.classList.remove('bg-blue-500/10', 'text-blue-400', 'border-blue-500/20');
                    btn.classList.add('bg-zinc-700', 'text-zinc-400', 'border-transparent');
                }
            },
            toggleSmooth(forceState) {
                // Explicitly handle state
                if (forceState !== undefined) {
                    this.isSmooth = forceState;
                } else {
                    this.isSmooth = !this.isSmooth;
                }
                
                const btn = document.getElementById('btn-smooth');
                if (this.isSmooth) {
                    btn.className = "text-xs px-2 py-0.5 rounded bg-blue-500/10 text-blue-400 border border-blue-500/20 transition-colors";
                } else {
                    btn.className = "text-xs px-2 py-0.5 rounded bg-zinc-700 text-zinc-400 border border-transparent hover:text-zinc-200 transition-colors";
                }
            },

            showModal(title, msg, action) {
                document.getElementById('confirm-title').innerText = title;
                document.getElementById('confirm-msg').innerText = msg;
                this.pendingAction = action;
                document.getElementById('confirm-modal').classList.remove('hidden');
            },
            closeModal() { document.getElementById('confirm-modal').classList.add('hidden'); this.pendingAction = null; },
            executeConfirm() { if (this.pendingAction) this.pendingAction(); this.closeModal(); },
            confirmClearStage() { this.showModal("Clear Stage?", "Remove all figures from current frame?", () => { this.figures = []; this.render(); }); },
            confirmNewProject() { this.showModal("New Project?", "Discard current animation?", () => { this.newProject(); }); },
            showClearModal() { this.confirmClearStage(); }, confirmClear() { this.executeConfirm(); },

            newProject() {
                this.frames = []; this.frameDelays = []; this.figures = []; this.currentFrameIndex = 0; this.bgImage = null;
                document.getElementById('canvas-w').value = 800; document.getElementById('canvas-h').value = 500;
                this.setCanvasSize(); this.addFigure(); this.render(); this.updateTimeline();
            },

            setCanvasSize() {
                const w = parseInt(document.getElementById('canvas-w').value) || 800;
                const h = parseInt(document.getElementById('canvas-h').value) || 500;
                this.canvas.width = w; this.canvas.height = h; this.render();
            },

            loadBackground(input) {
                if (input.files && input.files[0]) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = new Image();
                        img.onload = () => { this.bgImage = img; this.render(); };
                        img.src = e.target.result;
                    };
                    reader.readAsDataURL(input.files[0]);
                }
            },

            saveProject() {
                const data = { version: 2, width: this.canvas.width, height: this.canvas.height, fps: this.fps, frames: this.frames, delays: this.frameDelays };
                const blob = new Blob([JSON.stringify(data)], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url; a.download = 'project.json'; a.click();
            },

            loadProject(input) {
                if (input.files && input.files[0]) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const data = JSON.parse(e.target.result);
                            if(data.width) { document.getElementById('canvas-w').value = data.width; document.getElementById('canvas-h').value = data.height; this.setCanvasSize(); }
                            if(data.fps) { this.updateFps(data.fps); document.getElementById('fps-display').innerText = data.fps; }
                            this.frames = data.frames.map(frameData => {
                                return frameData.map(figData => {
                                    const fig = new Figure(); Object.assign(fig, figData);
                                    fig.joints = figData.joints.map(jData => {
                                        const j = new Joint(); Object.assign(j, jData); return j;
                                    });
                                    return fig;
                                });
                            });
                            if (data.delays && data.delays.length === this.frames.length) this.frameDelays = data.delays;
                            else this.frameDelays = new Array(this.frames.length).fill(1.0);
                            this.currentFrameIndex = 0; this.loadFrame(0); this.updateTimeline();
                        } catch (err) { alert("Error loading file: " + err); }
                    };
                    reader.readAsText(input.files[0]);
                }
            },

            async exportGif() {
                if (this.frames.length === 0) return;
                document.getElementById('loading-modal').classList.remove('hidden');
                try {
                    const response = await fetch('https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js');
                    const workerBlob = await response.blob();
                    const workerUrl = URL.createObjectURL(workerBlob);
                    const gif = new GIF({ workers: 2, quality: 10, width: this.canvas.width, height: this.canvas.height, workerScript: workerUrl });
                    const wasPlaying = this.isPlaying; if(wasPlaying) this.stop();
                    const originalIndex = this.currentFrameIndex;
                    const originalFigures = this.figures;
                    const baseDelay = 1000 / this.fps;

                    for (let i = 0; i < this.frames.length; i++) {
                        const durationMult = this.frameDelays[i] || 1.0;
                        const steps = this.isSmooth ? Math.max(1, Math.round(5 * durationMult)) : 1;
                        const stepDelay = (baseDelay * durationMult) / steps;
                        const frameA = this.frames[i];
                        const nextIdx = (i + 1) % this.frames.length;
                        
                        if (!this.isLooping && i === this.frames.length - 1) {
                             this.figures = frameA.map(f => f.clone());
                             this.renderFrameToCtx();
                             gif.addFrame(this.ctx, {copy: true, delay: baseDelay * durationMult});
                        } else {
                            const frameB = this.frames[nextIdx];
                            for (let s = 0; s < steps; s++) {
                                let t = s / steps; 
                                if (!this.isSmooth) t = 0;
                                this.renderInterpolated(frameA, frameB, t, false);
                                this.renderFrameToCtx(false);
                                gif.addFrame(this.ctx, {copy: true, delay: stepDelay});
                                if (!this.isSmooth) break;
                            }
                        }
                    }
                    gif.on('finished', (blob) => {
                        document.getElementById('loading-modal').classList.add('hidden');
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a'); a.href = url; a.download = 'animation.gif'; a.click();
                        this.currentFrameIndex = originalIndex; this.figures = originalFigures; this.render();
                    });
                    gif.render();
                } catch (err) {
                     document.getElementById('loading-modal').classList.add('hidden'); console.error(err);
                     alert("GIF Error. Try hosting on https or localhost.");
                }
            },
            
            renderFrameToCtx(showHandles = false) {
                this.ctx.fillStyle = "#ffffff"; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                if (this.bgImage) this.ctx.drawImage(this.bgImage, 0, 0, this.canvas.width, this.canvas.height);
                this.figures.forEach(fig => { fig.updatePositions(); this.drawFigure(fig, showHandles); });
            },

            addFrame() {
                // FIX: Do NOT auto-save the current frame when adding a new one.
                // This prevents overwriting the previous pose with the new one.
                // "Add Frame" acts as a snapshot of the CURRENT state into a NEW slot.
                
                const currentDelay = (this.frameDelays.length > 0 && this.frameDelays[this.currentFrameIndex] !== undefined) ? this.frameDelays[this.currentFrameIndex] : 1.0;
                const snapshot = this.figures.map(f => f.clone());
                
                if (this.frames.length === 0) {
                    this.frames.push(snapshot); 
                    this.frameDelays.push(currentDelay); 
                    this.currentFrameIndex = 0;
                } else {
                    // Append logic
                    this.frames.splice(this.currentFrameIndex + 1, 0, snapshot);
                    this.frameDelays.splice(this.currentFrameIndex + 1, 0, currentDelay);
                    this.currentFrameIndex++;
                }
                
                this.updateTimeline(); 
                this.render(); 
                this.scrollToFrame(this.currentFrameIndex);
            },

            deleteFrame() {
                if (this.frames.length === 0) return;
                this.frames.splice(this.currentFrameIndex, 1); this.frameDelays.splice(this.currentFrameIndex, 1);
                if (this.frames.length === 0) this.currentFrameIndex = 0;
                else if (this.currentFrameIndex >= this.frames.length) this.currentFrameIndex = this.frames.length - 1;
                this.loadFrame(this.currentFrameIndex); this.updateTimeline();
            },

            deleteFrameAtIndex(index) {
                if (this.frames.length === 0) return;
                this.frames.splice(index, 1); this.frameDelays.splice(index, 1);
                if (this.frames.length === 0) this.currentFrameIndex = 0;
                else if (this.currentFrameIndex >= index) this.currentFrameIndex = Math.max(0, this.currentFrameIndex - 1);
                if (this.frames.length > 0) this.loadFrame(this.currentFrameIndex);
                this.updateTimeline();
            },

            saveFrame(isInit = false) {
                if (this.frames.length === 0 && !isInit) return;
                const snapshot = this.figures.map(f => f.clone());
                if (isInit) { this.frames = [snapshot]; this.frameDelays = [1.0]; }
                else this.frames[this.currentFrameIndex] = snapshot;
            },

            loadFrame(index, autoSave = true) {
                if (this.frames.length === 0) return; 
                // Only auto-save if we are navigating away, NOT if stopping playback (to avoid saving tween states)
                if (autoSave && this.frames[this.currentFrameIndex]) this.frames[this.currentFrameIndex] = this.figures.map(f => f.clone());
                this.currentFrameIndex = index;
                this.figures = this.frames[index].map(f => f.clone());
                const delay = this.frameDelays[index] || 1.0;
                document.getElementById('frame-duration').value = delay;
                document.getElementById('duration-display').innerText = delay.toFixed(1) + 'x';
                this.render(); this.updateTimelineUiState();
            },

            play() {
                if (this.isPlaying || this.frames.length === 0) return; 
                this.saveFrame(); this.isPlaying = true;
                document.getElementById('btn-play').classList.add('hidden');
                document.getElementById('btn-stop').classList.remove('hidden');
                this.lastTime = performance.now(); this.playbackAccumulator = 0;
                if (this.currentFrameIndex >= this.frames.length - 1) this.currentFrameIndex = 0;
                requestAnimationFrame((t) => this.playTick(t));
            },

            stop() {
                this.isPlaying = false;
                document.getElementById('btn-play').classList.remove('hidden');
                document.getElementById('btn-stop').classList.add('hidden');
                // Load frame WITHOUT auto-saving to discard any interpolation state
                if (this.frames.length > 0) this.loadFrame(this.currentFrameIndex, false);
            },

            playTick(now) {
                if (!this.isPlaying) return;
                const dt = now - this.lastTime; this.lastTime = now;
                const currentDelayMult = this.frameDelays[this.currentFrameIndex] || 1.0;
                const msPerFrame = (1000 / this.fps) * currentDelayMult;
                this.playbackAccumulator += dt;

                if (this.playbackAccumulator >= msPerFrame) {
                    this.playbackAccumulator -= msPerFrame;
                    this.currentFrameIndex++;
                    // Allow playing the last frame fully before checking loop
                    if (this.currentFrameIndex >= this.frames.length) {
                        if (this.isLooping) {
                            this.currentFrameIndex = 0; 
                        } else { 
                            this.currentFrameIndex = this.frames.length - 1;
                            this.stop(); 
                            return; 
                        }
                    }
                    this.updateTimelineUiState();
                }

                if (this.isSmooth) {
                    let t = this.playbackAccumulator / msPerFrame; if (t > 1) t = 1;
                    const frameA = this.frames[this.currentFrameIndex];
                    const nextIdx = (this.currentFrameIndex + 1) % this.frames.length;
                    if (!this.isLooping && this.currentFrameIndex === this.frames.length - 1) this.figures = frameA.map(f => f.clone());
                    else this.renderInterpolated(frameA, this.frames[nextIdx], t);
                } else {
                    this.figures = this.frames[this.currentFrameIndex].map(f => f.clone());
                    this.render();
                }
                requestAnimationFrame((t) => this.playTick(t));
            },

            renderInterpolated(frameA, frameB, t, draw = true) {
                const interpolated = [];
                frameA.forEach(figA => {
                    const figB = frameB.find(f => f.id === figA.id);
                    if (figB) {
                        const newFig = figA.clone();
                        newFig.x = figA.x + (figB.x - figA.x) * t;
                        newFig.y = figA.y + (figB.y - figA.y) * t;
                        newFig.scale = figA.scale + (figB.scale - figA.scale) * t;
                        newFig.joints.forEach(jA => {
                            const jB = figB.joints.find(j => j.id === jA.id);
                            if (jB) {
                                let diff = jB.angle - jA.angle;
                                while (diff < -Math.PI) diff += Math.PI * 2;
                                while (diff > Math.PI) diff -= Math.PI * 2;
                                jA.angle += diff * t;
                            }
                        });
                        interpolated.push(newFig);
                    } else { interpolated.push(figA.clone()); }
                });
                this.figures = interpolated;
                if(draw) this.render();
            },

            updateFps(val) {
                this.fps = parseInt(val);
                document.getElementById('fps-display').innerText = val;
            },

            getMousePos(e) {
                const rect = this.canvas.getBoundingClientRect();
                return { x: e.clientX - rect.left, y: e.clientY - rect.top };
            },

            onMouseDown(e) {
                if (this.isPlaying) return;
                const pos = this.getMousePos(e); this.mouseX = pos.x; this.mouseY = pos.y;
                for (let i = this.figures.length - 1; i >= 0; i--) {
                    const fig = this.figures[i]; fig.updatePositions(); 
                    const root = fig.joints.find(j => j.parentId === null);
                    if (Math.hypot(pos.x - root.x, pos.y - root.y) < this.handleRadius * 2) {
                        this.dragTarget = { figure: fig, type: 'root', joint: root, offsetX: pos.x - fig.x, offsetY: pos.y - fig.y };
                        this.selectFigure(fig); this.render(); return;
                    }
                    for (let j of fig.joints) {
                        if (j.parentId === null) continue; 
                        if (Math.hypot(pos.x - j.x, pos.y - j.y) < this.handleRadius * 2) {
                            this.dragTarget = { figure: fig, type: 'joint', joint: j };
                            this.selectFigure(fig); this.render(); return;
                        }
                    }
                }
                this.deselectAll(); this.render();
            },

            onMouseMove(e) {
                const pos = this.getMousePos(e);
                if (!this.dragTarget && !this.isPlaying) {
                    let hovered = false;
                    for (let fig of this.figures) {
                        for(let j of fig.joints) { if (Math.hypot(pos.x - j.x, pos.y - j.y) < this.handleRadius * 2) { hovered = true; break; } }
                    }
                    this.canvas.style.cursor = hovered ? 'pointer' : 'crosshair';
                }
                if (!this.dragTarget) return;
                if (this.dragTarget.type === 'root') {
                    const fig = this.dragTarget.figure;
                    fig.x = pos.x - this.dragTarget.offsetX; fig.y = pos.y - this.dragTarget.offsetY;
                } else {
                    const joint = this.dragTarget.joint; const fig = this.dragTarget.figure;
                    const parent = fig.joints.find(j => j.id === joint.parentId);
                    if (parent) {
                        const dx = pos.x - parent.x; const dy = pos.y - parent.y;
                        const newAngle = Math.atan2(dy, dx); const delta = newAngle - joint.angle;
                        joint.angle = newAngle; this.rotateHierarchy(fig, joint.id, delta);
                    }
                }
                this.render();
            },

            rotateHierarchy(fig, parentId, delta) {
                fig.joints.forEach(j => { if (j.parentId === parentId) { j.angle += delta; this.rotateHierarchy(fig, j.id, delta); } });
            },

            onMouseUp(e) { this.dragTarget = null; },

            selectFigure(fig) {
                this.figures.forEach(f => f.selected = false); fig.selected = true;
                document.getElementById('color-picker').value = fig.color;
            },
            deselectAll() { this.figures.forEach(f => f.selected = false); },

            flipFigure() {
                const fig = this.figures.find(f => f.selected); if (!fig) return;
                fig.joints.forEach(j => { if (j.parentId !== null) j.angle = Math.PI - j.angle; });
                this.render();
            },
            centerFigure() {
                const fig = this.figures.find(f => f.selected); if (!fig) return;
                fig.x = this.canvas.width / 2; fig.y = this.canvas.height / 2; this.render();
            },
            scaleFigure(factor) {
                const fig = this.figures.find(f => f.selected); if (!fig) return;
                fig.scale *= factor; this.render();
            },
            setFigureColor(hex) {
                const fig = this.figures.find(f => f.selected); if (!fig) return;
                fig.color = hex; document.getElementById('color-preview').style.backgroundColor = hex;
                this.render();
            },

            render() {
                this.ctx.fillStyle = "#ffffff"; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                if (this.bgImage) this.ctx.drawImage(this.bgImage, 0, 0, this.canvas.width, this.canvas.height);
                
                this.showOnion = document.getElementById('onion-check').checked;
                // FIX: Show onion skin if active, not playing, and there are frames.
                if (this.showOnion && !this.isPlaying && this.frames.length > 0) {
                    let prevFrame = null;
                    
                    // Logic: If we are at the END of the timeline (e.g. modifying the future frame),
                    // show the current timeline frame as the ghost.
                    // If we are in the middle, show the previous frame.
                    if (this.currentFrameIndex === this.frames.length - 1) {
                        prevFrame = this.frames[this.currentFrameIndex];
                    } else if (this.currentFrameIndex > 0) {
                        prevFrame = this.frames[this.currentFrameIndex - 1];
                    }

                    if (prevFrame) {
                        this.ctx.globalAlpha = 0.3;
                        prevFrame.forEach(fig => { fig.updatePositions(); this.drawFigure(fig, false); });
                        this.ctx.globalAlpha = 1.0;
                    }
                }
                
                this.figures.forEach(fig => { fig.updatePositions(); this.drawFigure(fig, !this.isPlaying); });
            },

            drawFigure(fig, showHandles) {
                this.ctx.strokeStyle = fig.color; this.ctx.fillStyle = fig.color;
                this.ctx.lineCap = 'round'; this.ctx.lineJoin = 'round';

                fig.joints.forEach(j => {
                    if (j.parentId === null) return;
                    const parent = fig.joints.find(p => p.id === j.parentId);
                    if (!parent) return;
                    this.ctx.lineWidth = (j.thickness || 14) * fig.scale; // USE CUSTOM THICKNESS
                    if (j.type === SEGMENT_CIRCLE) {
                        const dx = j.x - parent.x; const dy = j.y - parent.y;
                        const angle = Math.atan2(dy, dx);
                        const r = (j.length / 2) * fig.scale; // Radius scaled
                        // For circle segment: length is essentially diameter in typical usage, or user drags length.
                        // Let's place circle at midpoint? No, Pivot circle segment ends at the joint.
                        // Let's use the same logic: Joint is the end/handle.
                        // Draw line to base of circle.
                        const cx = j.x - Math.cos(angle) * (r * 0.5);
                        const cy = j.y - Math.sin(angle) * (r * 0.5);
                        const chinX = cx - Math.cos(angle) * r;
                        const chinY = cy - Math.sin(angle) * r;

                        this.ctx.beginPath();
                        this.ctx.moveTo(parent.x, parent.y);
                        this.ctx.lineTo(chinX, chinY);
                        this.ctx.stroke();
                        
                        this.ctx.beginPath();
                        this.ctx.arc(cx, cy, r, 0, Math.PI * 2);
                        this.ctx.fill();
                    } else {
                        this.ctx.beginPath();
                        this.ctx.moveTo(parent.x, parent.y);
                        this.ctx.lineTo(j.x, j.y);
                        this.ctx.stroke();
                    }
                });

                if (showHandles) {
                    fig.joints.forEach(j => {
                        this.ctx.beginPath();
                        
                        let radius = this.handleRadius;
                        
                        if (j.parentId === null) {
                            this.ctx.fillStyle = '#f97316'; 
                            radius += 2; 
                        } else {
                            this.ctx.fillStyle = '#ef4444'; 
                        }
                        
                        this.ctx.arc(j.x, j.y, radius, 0, Math.PI * 2);
                        
                        if (this.dragTarget && this.dragTarget.joint === j) {
                            this.ctx.fillStyle = '#3b82f6'; 
                            this.ctx.strokeStyle = '#fff';
                            this.ctx.lineWidth = 2;
                            this.ctx.stroke();
                        }
                        
                        this.ctx.fill();
                    });
                    
                    if (fig.selected) {
                         const root = fig.joints.find(j => j.parentId === null);
                         if(root) {
                             this.ctx.beginPath();
                             this.ctx.arc(root.x, root.y, this.handleRadius + 4, 0, Math.PI*2);
                             this.ctx.strokeStyle = 'rgba(59, 130, 246, 0.5)';
                             this.ctx.lineWidth = 2;
                             this.ctx.stroke();
                         }
                    }
                }
            },

            handleDragStart(e, idx) { this.draggedFrameIndex = idx; e.dataTransfer.effectAllowed = 'move'; },
            handleDragOver(e) { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; },
            handleDrop(e, targetIdx) {
                e.preventDefault();
                const fromIdx = this.draggedFrameIndex;
                if (fromIdx === targetIdx) return;
                
                const movingFrame = this.frames[fromIdx];
                const movingDelay = this.frameDelays[fromIdx];
                
                this.frames.splice(fromIdx, 1);
                this.frameDelays.splice(fromIdx, 1);
                
                this.frames.splice(targetIdx, 0, movingFrame);
                this.frameDelays.splice(targetIdx, 0, movingDelay);
                
                if (this.currentFrameIndex === fromIdx) this.currentFrameIndex = targetIdx;
                else if (this.currentFrameIndex > fromIdx && this.currentFrameIndex <= targetIdx) this.currentFrameIndex--;
                else if (this.currentFrameIndex < fromIdx && this.currentFrameIndex >= targetIdx) this.currentFrameIndex++;
                
                this.updateTimeline(); this.loadFrame(this.currentFrameIndex);
            },

            updateTimeline() {
                const container = document.getElementById('timeline-track');
                container.innerHTML = '';
                this.frames.forEach((frame, idx) => {
                    const wrapper = document.createElement('div');
                    wrapper.className = `frame-thumb relative min-w-[80px] h-[64px] bg-zinc-800 rounded-md border-2 cursor-pointer hover:border-zinc-500 overflow-hidden shrink-0 ${idx === this.currentFrameIndex ? 'active border-blue-500' : 'border-zinc-700'}`;
                    wrapper.onclick = () => this.loadFrame(idx);
                    
                    wrapper.draggable = true;
                    wrapper.ondragstart = (e) => app.handleDragStart(e, idx);
                    wrapper.ondragover = (e) => app.handleDragOver(e);
                    wrapper.ondrop = (e) => app.handleDrop(e, idx);

                    if (this.frames.length > 1) {
                        const del = document.createElement('div');
                        del.innerHTML = '';
                        del.className = 'delete-btn absolute top-0 right-0 bg-red-600 text-white w-4 h-4 text-[10px] items-center justify-center font-bold z-10 rounded-bl shadow-sm';
                        del.onclick = (e) => { e.stopPropagation(); app.deleteFrameAtIndex(idx); };
                        wrapper.appendChild(del);
                    }
                    
                    const delay = this.frameDelays[idx] || 1.0;
                    
                    const badge = document.createElement('div');
                    badge.innerText = delay.toFixed(1) + 'x';
                    badge.className = `absolute top-0 left-0 text-[9px] px-1.5 py-0.5 font-mono z-10 rounded-br font-bold ${delay > 1.0 ? 'bg-blue-600 text-white' : 'bg-zinc-700 text-zinc-400'}`;
                    wrapper.appendChild(badge);

                    const barContainer = document.createElement('div');
                    barContainer.className = 'absolute bottom-0 left-0 right-0 h-1.5 bg-zinc-900 mt-px';
                    
                    const barFill = document.createElement('div');
                    let widthPct = (delay / 10.0) * 100;
                    widthPct = Math.max(5, widthPct); 
                    
                    barFill.style.width = widthPct + '%';
                    barFill.className = `h-full ${delay > 1.0 ? 'bg-blue-500' : 'bg-zinc-600'}`;
                    
                    barContainer.appendChild(barFill);
                    wrapper.appendChild(barContainer);

                    const cv = document.createElement('canvas'); cv.width = 80; cv.height = 56;
                    const ctx = cv.getContext('2d');
                    const sc = Math.min(80/this.canvas.width, 56/this.canvas.height);
                    ctx.scale(sc, sc);
                    
                    frame.forEach(fig => {
                        fig.updatePositions();
                        ctx.strokeStyle = fig.color; ctx.fillStyle = fig.color; ctx.lineWidth = 14 * fig.scale;
                        ctx.lineCap = 'round'; ctx.lineJoin = 'round';
                        fig.joints.forEach(j => {
                            if (!j.parentId) return;
                            const p = fig.joints.find(x => x.id === j.parentId);
                            if (!p) return;
                            ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(j.x, j.y); ctx.stroke();
                            if(j.type === SEGMENT_CIRCLE) {
                                ctx.beginPath(); ctx.arc(j.x, j.y, j.radius*fig.scale, 0, Math.PI*2); ctx.fill();
                            }
                        });
                    });
                    
                    wrapper.appendChild(cv);
                    
                    const n = document.createElement('span');
                    n.className = "absolute bottom-2 left-1 text-[8px] font-bold text-zinc-500";
                    n.innerText = idx + 1;
                    wrapper.appendChild(n);
                    
                    container.appendChild(wrapper);
                });
                this.updateTimelineUiState();
            },

            updateTimelineUiState() {
                document.getElementById('frame-counter').innerText = `${this.currentFrameIndex + 1} / ${this.frames.length}`;
                
                const thumbs = document.querySelectorAll('.frame-thumb');
                thumbs.forEach((t, i) => {
                    if (i === this.currentFrameIndex) {
                        t.classList.add('active', 'border-blue-500');
                        t.classList.remove('border-zinc-700');
                    } else {
                        t.classList.remove('active', 'border-blue-500');
                        t.classList.add('border-zinc-700');
                    }
                });
            },

            scrollToFrame(index) {
                const thumbs = document.querySelectorAll('.frame-thumb');
                if (thumbs[index]) {
                    thumbs[index].scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
                }
            },
            
            newProject() {
                this.frames = [];
                this.frameDelays = [];
                this.figures = [];
                this.currentFrameIndex = 0;
                this.bgImage = null;
                document.getElementById('canvas-w').value = 800;
                document.getElementById('canvas-h').value = 500;
                this.setCanvasSize();
                this.addFigure();
                // REMOVED this.saveFrame(true) to keep it empty on new project
                this.render();
                this.updateTimeline();
            },
        };

        window.onload = () => app.init();
    </script>
</body>
</html>